syntax = "proto3";

package SlurmxGrpc;
option go_package = "/protos";

import "PublicDefs.proto";

message Negotiation {
  uint32 version = 1;
}

message StreamRequestNegotiation {
  uint32 version = 1;
}

message StreamReplyResult {
  bool ok = 1;
  string reason = 2; // Set when failed
}

message InteractiveTaskAllocRequest {
  Resources required_resources = 1;
  string partition_name = 2;
  uint64 time_limit_sec = 3;
}

message InteractiveTaskAllocReply {
  bool ok = 1;
  oneof payload {
    uint32 task_id = 2;
    string reason = 3;
  }
}

message InteractiveTaskAllocationDetail {
  /* Used to connect the SlurmXd node */
  uint32 node_index = 1;
  string ipv4_addr = 2;
  uint32 port = 3;
  bytes resource_uuid = 4;
}

message QueryInteractiveTaskAllocDetailRequest {
  uint32 task_id = 1;
}

message QueryInteractiveTaskAllocDetailReply {
  bool ok = 1;
  InteractiveTaskAllocationDetail detail = 2;
}

message StreamRequestCheckResource {
  bytes resource_uuid = 1;
  uint32 task_id = 2;
}

message StreamRequestExecutiveInfo {
  string executive_path = 1;
  repeated string arguments = 2;
}

message StreamReplyIo {
  string buf = 1;
}

message StreamReplyExitStatus {
  enum ExitReason {
    Normal = 0;
    Signal = 1;
  }

  ExitReason reason = 1;
  uint32 value = 2;
}

message SrunXStreamRequest{
  enum Type {
    NegotiationType = 0;
    CheckResourceType = 1;
    ExecutiveInfoType = 2;
    SignalType = 3;
  }
  Type type = 1;

  oneof payload {
    StreamRequestNegotiation negotiation = 2;
    StreamRequestExecutiveInfo exec_info = 3;
    int32 signum = 4;
    StreamRequestCheckResource check_resource = 5;
  }
}

message SrunXStreamReply {
  enum Type {
    IoRedirectionType = 0;
    ExitStatusType = 1;
    ResultType = 2;
  }
  Type type = 1;

  oneof payload {
    StreamReplyIo io = 2 ;
    StreamReplyExitStatus exit_status = 3;
    StreamReplyResult result = 4;
  }
}

message SlurmXdRegisterRequest {
  Negotiation header = 1;

  uint32 port = 2;

  /* Todo: Add fields describing what tasks the SlurmXd is still running and the current usage of this node in case that
      from CtlXd's view, this node is down due to network problem and however this node is still running.
  */
}

message SlurmXdRegisterResult {
  bool ok = 1;
  oneof payload {
    // If ok is true
    XdNodeId node_id = 2;

    // If ok is false, reason is set.
    string reason = 3;
  }
}

message TaskStatusChangeRequest {
  uint32 task_id = 1;
  uint32 node_index = 2;
  TaskStatus new_status = 3;
  string reason = 4;
}

message TaskStatusChangeReply {
  bool ok = 1;
}

message SubmitBatchTaskRequest {
  TaskToCtlXd task = 1;
}

message SubmitBatchTaskReply {
  bool ok = 1;
  oneof payload{
    uint32 task_id = 2;
    string reason = 3;
  }
}

message ExecuteTaskRequest {
  TaskToXd task = 1;
}

message ExecuteTaskReply {
  bool ok = 1;
  string reason = 2;
}

message TerminateTaskRequest {
  uint32 task_id = 1;
}

message TerminateTaskReply {
  bool ok = 1;
  string reason = 2;
}

message QueryJobsInPartitionRequest {
  string partition = 1;
}

message QueryJobsInPartitionReply {
  repeated TaskToCtlXd task_metas = 1;
  repeated TaskStatus task_status = 2;
  repeated string allocated_nodes = 3;
  repeated uint32 task_ids = 4;
}

message QueryNodeInfoRequest {
  string node_name = 1;
}

message QueryNodeInfoReply {
  repeated NodeInfo node_info_list = 1;
}

message QueryPartitionInfoRequest {
  string partition_name = 1;
}

message QueryPartitionInfoReply {
  repeated PartitionInfo partition_info = 1;
}


// Todo: Divide service into two parts: one for SlurmXd and one for SrunX
//  We need to distinguish the message sender
//  and have some kind of authentication
service SlurmCtlXd {
  /* RPCs called from SlurmXd*/
  rpc RegisterSlurmXd(SlurmXdRegisterRequest) returns (SlurmXdRegisterResult);
  rpc TaskStatusChange(TaskStatusChangeRequest) returns (TaskStatusChangeReply);


  /* RPCs called from SrunX */
  /* When SrunX request an interactive job, it will first request SrunX to allocate
     an interactive task and get the related meta information. */
  rpc AllocateInteractiveTask(InteractiveTaskAllocRequest) returns (InteractiveTaskAllocReply);
  rpc QueryInteractiveTaskAllocDetail(QueryInteractiveTaskAllocDetailRequest) returns (QueryInteractiveTaskAllocDetailReply);

  rpc TerminateTask(TerminateTaskRequest) returns (TerminateTaskReply);


  /* RPCs called from sbatch */
  rpc SubmitBatchTask(SubmitBatchTaskRequest) returns (SubmitBatchTaskReply);


  /* RPCs called from SqueueX */
  rpc QueryJobsInPartition(QueryJobsInPartitionRequest) returns (QueryJobsInPartitionReply);

  rpc QueryNodeInfo(QueryNodeInfoRequest) returns (QueryNodeInfoReply);
  rpc QueryPartitionInfo(QueryPartitionInfoRequest) returns (QueryPartitionInfoReply);
}

service SlurmXd {
  /* ----------------------------------- Called from SlurmCtlXd ---------------------------------------------------- */
  // Todo: Granting and revoking Resource UUID can be merged into ExecuteTask and TerminateTask. Remove this two RPC.

  /* If the task is a batch task, it will run immediately.
     If the task is an interactive task, slurmxd will just allocate the resource and waiting for
     further SrunXStream to execute a real task.
   */
  rpc ExecuteTask(ExecuteTaskRequest) returns(ExecuteTaskReply);

  /*
  If the task is an interactive task, the resource uuid is also revoked.
   If there's no process in this interactive task, just deallocate all the resources.
   If there are processes in this interactive task, kill all the processes and deallocate resources.
  If the task is a batch task, just kill it.
  */
  rpc TerminateTask(TerminateTaskRequest) returns (TerminateTaskReply);


  /* ----------------------------------- Called from SrunX --------------------------------------------------------- */
  rpc SrunXStream(stream SrunXStreamRequest) returns (stream SrunXStreamReply);
}